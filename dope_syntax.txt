# Language goals :
# 
# - be consistant without ambiguities
# - support combinatorial functional programming
# - expression syntax follows APL / J / BQN Style, while also removing 
#     the ambiguity of unary and binary operators entirely
# - The language should be terse enough, but without the goal of code golf, Haskell
# - be strongly typed with basic type inference
# - With a good compiler, it should be possible to make statically typed
# - obviate parenthesis where possible
#    but a normal form similar to S-expressions
# - be line oriented
# - work as a scripting language
# - have modules
# - have no circular dependancies
# - Be it's own manefest format


# 1: u y  :: J/APL
y.u ~> c1.u1              # where u1 is a constant function

# 2: x B y  :: J/APL
y B x ~> c1 B c2          # this can be seen as a constant train  uc B uc

# 3: (B u)y  :: J         # note this is not a train despite the (? B u) pattern
y . u B ~> u1_c1 B c1

# 4: x(B u)y  :: J
y . u B right _ x ~> u1_c1 B right_c1 _ c2
                  ~> u1_c1_c2 B right_c1_c2
                  ~> u1_c1_c2 B c2

                                     # assuming that u1 returns data value
                  ~> u1_c1 B c2      # the second argument will be ignored for a unary function

# 5: (u2 B u1)y  :: J/APL
y . u1 B u2 ~> c1.(u1 B u2)
          ~> u1_c1 B u2_c1 

# 6: x(B3 B2 B1)y  :: J/APL
y (B1 B2 B3) x ~> c1.(B1 B2 B3) _ c2
               ~> B1_c1 B2 B3_c1 _ c2
               ~> B1_c1_c2 B2 B3_c1_c2

# 7: x(u@] B2 B1)y  :: J/APL
y (B1 B2 u) x ~> c1.(B1 B2 u2) _ c2
              ~> B1_c1 B2 u2_c1 _ c2 
              ~> B1_c1_c2 B2 u2_c1_c2 

# 8: x(u@[ B2 B1)y  :: J
y (B1 B2 u.right) x   ~> c1 . B1 B2 B3 c2 # note that now it has pattern 6:

# 9: x(B2 B1 u)y
y (u B1 B2) x  ~> c1.(u1 B1 B2) _ c2
               ~> u1_c1 B1 B2_c1 _ c2
               ~> u1_c1_c2 B1 B2_c1_c2
                                     # assuming that u1 returns data value
               ~> u1_c1 B1 B2_c1_c2


# Now moving away from J language syntax

# chaining 'u'
a.b.c   ~> (b_a).c  # note these are equivalent
        ~> c_(b_a)

a.(b.c) ~> a.(c_b) 
        ~> c_b_a

a_b_c <=> (a_b)_c 

# corner cases
a b ~> {c :: a_c b a}
a . b c ~>  a_b c a

B1 u B2 ~> {a b :: B1_a_b.u} # assuming u returns a data value

a (b c) ~> {d :: a_d (b c) d}
           {d :: (b_(a_d) c a_d)_d}
           {d :: (a_d.b c a_d)_d}
           {d :: c_(a_d.b)_(a_d)_d}

a . b (c d) ~> d_(b_a.c)_(b_a)_a

Examples


3.double  => 6
3 * 2     => 6
3.(2 *)   => 6

3.recip.double        ~> 2/3
3.(1 div).(2 *)       ~> 2/3
3.(1 div.flip) . * 2  ~> 2/3
3.div_1.(*_2)         ~> 2/3  # underscores allow functional programming where functions are composed by value, the precedence is reversed


# a clarification of '_' and '.' composition syntax
# examples of the mean average, all of these are equivalent
[1 2 3] . reflex_(0 fold left_+) div length   ~> 2
[1 2 3] . (left_+ fold_0) div length          ~> 2
[1 2 3] . (0 fold_+) div length               ~> 2   # here fold right curries +
[1 2 3] . +.(fold_0) div length               ~> 2   
[1 2 3] . fold_0_+ div length                 ~> 2
[1 2 3] . 0.fold_+ div length                 ~> 2
[1 2 3] . (0 fold +) div length               ~> 2  # this last version should now be possible

# define a function with '::'
sum :: 0 fold +

(mean ::            # you can do it on mutiple lines if it is of form (name : body)
  sum div length
)

[1 2 3].mean


# you can also write it like so
[1 2 3] . mean :: (sum :: 0.fold_+ ) (div :: %) length :: count
[1 2 3].(mean ::
  (sum :: 0.fold_+ ) (div :: %) length :: count
)

# if you want a more classic way of making definitions, 
(mean [:: 
    sum :: 0.fold_+ 
    div :: %
    len :: count
  ]
  sum div len
)

# when types are added the '::' is wrapped in parenthesis
# here is a function with fully qualified types,
# obviously overkill

(mean (:: [num] [num])                    # takes a [num], returns a [num]

  sum    (:: [num] [num])     0_fold_+
  div    (:: [num] num [num]) %          # takes a '[num]', then a 'num', returns a '[num]'
  length (:: [_] num)         count      # _ here indicates that the inner type of length can be ignored

)                                        # this is a valid function as is, the defintions return themselves

mean-plus :: 0.fold_+ % count        # good taste would dictate that you consider both the short and explicit versions


# a higher order function may have a longer type signature
(higher-order (:: (num num) (num bool) [num] bool)
  left_map (@ :: compose) right_map
)

# Some examples

4.recip + 7  ~> 29/4

[4 5 6].(recip + count)  ~> [13/4 16/5 19/6] 

[3 4 5].(+_1 max (recip + [4 4 4])) ~> [4 5 6] max ([1/3 1/4 1/5] + [4 4 4])
                                    ~> [4 5 6] max [13/3 17/4 21/5]
                                    ~> [13/3 5 6]


4 (+ * - ^ =) 3 . (4 . + * - ^ = _ 3) ==  ~> true

# Module paths are done with ' ` ' syntax between identifiers

a :: std`filesystem`cd    # assign cd to a

(matmul ::
  [[1 0] [0 1]] 
  std`linear-algebra`*::
  [[1 2] [3 5]]
)

# Files
# start 'my-mod.lang'
::
(.`my-train ::
  .`double. (:: num num) 2 * 
  plus       :: +
  recip.     :: 1 div
)

.`my-train`+5 :: plus 5

# EOF

# using 'my-mod.lang'
# start 'main.lang'
[:: (m : my-mod)`(alias : my-train)`double]


a :: 4 m`my-train 5     # 'a' and 'b' are equivalent, because they use the same functions
b :: 4 alias 5

c :: + m`my-train`double.
c-prime :: + double.
d [(:: num) alias`+5] 3.+5   # the import wraps the type, the type MUST then have parenthesis
# EOF                        # else it will try to import 'num' 

# Files are functions
# start 'mean.lang'

#EOF

# as more imports are needed you may need more lines
[:: [std`filesystem .
    .`current-directory : cd           # this alias will be exported by the module  
    [(f : filesystem) .                # parenthesize the module name to import it '[(module) : ... ]'
                                       # then one can do '[: file item]'
                                       # here we have an alias  because of the '[(alias : module) : ... ]'
                                       # pattern, now one can do '[: f item]'
      file-len
      f-descriptor : file-descriptor
                                       # to disambiguate, alias requires parenthesis when on the same line
      (f-read : read) (f-open : open) f-close : close
    ]
  ]
  std`collections`_                    # imports everything from 'std`collections'
  .`lib`_                              # imports and exports everything from 'lib'
  std`os`[_ . version]                 # imports everything from 'std`os' hiding 'version'
  [std`pointer : [_ .                  # to have it on multiple lines you need this syntax
    to-ref
    (slice : _)                        # '(module-item : _)' is equivalent to 'module-item'
  ]] 
]


# the same as above but written cleanly
[:: 
  [std . 
    [filesystem .
      .`current-directory : cd
      [(f : file) .
        file-len
        file-descriptor : descriptor
        file-read : read
        file-open : open
        file-close : close
      ]
    ]
    collections`_
    os`[_ : version] 
    pointer`[_ : to-ref slice] 
  ]
  .`lib`_
]

# the same as above but written cleanly
[:: 
  [. std ` 
    {filesystem `
      .`current-directory : cd
      {(f : file) `
        file-len
        file-descriptor : descriptor
        file-read : read
        file-open : open
        file-close : close
      }
    }
    collections`_
    os`{:~ version} 
    pointer`{:~ to-ref slice}
  ]
  .`lib`_
]

[:: [. (m : my-mod)`(alias : my-train) `
  double 
  t : triple
  ]
]

# type anotations can be done on modules, as a sanity check
[(:: num num) 
  [(m (: [num] num) my-mod) : 
    [(a : my-train) : 
      (plus (: num num num) _)
      t (: num num) triple 
    ]
  ]
]

# on braces
# if something is self contained on one line, it does not require parenthesis
a :: b
# but implicitly there are parenthesis
(a :: b)



# more examples

[u1 u2 u3] . (left_id fold left_compose) call ~> [id.u1.u2.u3] # assuming left fold
[u1 u2 u3] id.fold_compose   ~> [id.u1.u2.u3]

4 + * - ^ % 2  ~> (4 + 2) * (4 - 2) ^ (4 % 2)
               ~> 6 * 2 ^ 2
               ~> 144


3 double. * (`triple right.) 4 ~> (3 double) * (3 (`triple right) 4)
                               ~> 6 * (4 triple)
                               ~> 6 * 12
                               ~> 72

2 double. * right_id 5 ~> (2 double) * (2 right_id 4) 
                       ~> 4 * (4 id)
                       ~> 16


# values

g   # identifier
5   # the literal '5'
+   # this is also an identifier
+_  # a Binary function curring the right argument
[b] # arrays

# a scalar value is represented with ' ` '
[]    # this too is a value
[`[1 2] `[3 4]] # note that without ' ` ' the scalars of the outer array would be numbers instead of vectors

# Array/List syntax
[1 2 3]           # 1D array (a vector), note that inside '[]' everything has the role of a value
[f g h]           # 1D array of functions
[[1 2] [3 4]]     # 2D array (a matrix), this is flat in memory
[`[1 2] `[3 4]]   # 1D array of 1D arrays
[(f.g.h.) 3]    # 1D array with 2 elements , were the first element is the result of (f g h)
[h_(g_f) 3]         # the same as the above
[]                # 1D empty array
[[] []]           # 2D empty array, shape '[2 0]' 
0 reshape [0 1 1] # 3D empty array, note that empty arrays of shape where the empty axis is not the last can only be made by computing it
5 unit-array.      # 0D unit array, holds single element 5

# TODO :: consider changing compliance to something other than '_'
# Compliants are like reverse traits, where Compliants implement data types

# for example, an array has expectations on how functions apply to them.

double (:: num num) 2 *
[1 2 3].double                         # this would error, so we will make the type '(: num num)' comply with array


_ : fmap-num                            # the '_' on the left represents a compliance
_ (: (num num) [num] [num]) fmap-num    # here is the explicit version

# a Compliant's value is its definition

[1 2 3].(_ :: fmap-num)_double ~> [2 4 6]

# but once a compliant is defined, it will apply automatically to conforming type signatures
   # first we have this expression
[0 1 2].(_ :: fmap-num).(1 +).(5 *) 


_ :: fmap-num
[0 1 2].(1 +).(5 *) 


   # check types with dummy identifiers
~> [0 1 2]
   .
   (f (:: [num] unknown) 
     (_ (:: (num num) [num] [num]) fmap-num).(g (:: num num) 1 +)
     .
     h(:: num num) 5 * 
   )    

~> [0 1 2]
   .
   (f [(:: [num] unknown) 
      _ (:: (num num) [num] [num]) fmap-num
     ]                                         # '.' is not a identifier, defining to it will result in 
                                               # being able to define while not transforming the passed value
     .
     fmap-num.(g (:: num num) 1 +)             # the value of the Compliant was already applied
     .
     h (:: num num) 5 * 
   )    

~> [0 1 2]
   .
   (f [(:: [num] unknown) 
       _ (:: (num num) [num] [num]) fmap-num
     ]

     g-prime (:: [num] [num]) fmap-num.(1 +)   # curry 'g' to make 'g-prime'
     .
     h (:: num num) 5 *                        # it is now apparent that h expects a 'num', but we pass a '[num]'
   )

~> [0 1 2]
   .
   (f [(:: [num] unknown) 
     _ (:: (num num) [num] [num]) fmap-num
     ]

     g-prime (:: [num] [num]) fmap-num.(1 +)
     .
     fmap-num_(h (: num num) 5 *)               # we have a compliant for '(num num) [num]',
   )                                            # that happens to return a '[num]'

~> [0 1 2]
   (f [(:: [num] (unknown : [num]))              # we now see that the unknown return type is '[num]'
     _ (:: (num num) [num] [num]) fmap-num
     ]    

     g-prime  (:: [num] [num]) fmap-num.(1 +)
     .
     h-prime  (:: [num] [num]) fmap-num.(5 *)   # curry 'h' to make 'h-prime'
   )                                           # it is now evident that the types line up

~> [0 1 2] . fmap-num.(1 +) . fmap-num.(5 *)     # if we simplify, we get the following
~> [1 2 3] . fmap-num.(5 *)                      # and evaluation become clear
~> [5 10 3]

 


# multiple Compliants
[::
  _ (:: (num num) [num] [num]) : fmap-num      # Compliant will be local

  (_`promote-num-to-array 
     :: ([num] [num]) num [num]                # Compliant will be exported, 
     (@ :: compose).unit-array                # with name 'module-name`_`promote-num-to-array'
  )

  inc. :: + 1                                   # of course, you can still define normal functions
]

# a compliant for a binary operator

# type anotation defining the type signature for a scope, 
# if followed by nothing on the line, or closed with parenthesis 
(_ :: (Op : num num num) [num] num [num]

    ({:3} fmap.after_curry-to)      (:: Op _ num [num])
    apply                           (:: (num [num]) [num] [num])
    {:2}                            (:: _ [num] _ [num])
)

# short version
_ (:: ((n : num) n n) [n] n [n]) {:3 fmap.after_curry-to :1 _ :2}

# if you import everything from a library,
# but it has a compliant that conflicts
# a prefered override, you can import hiding the function, then use it explicitly

# start 'micro-prelude.lang'
::
_`scalar->array (:: ([num] [num]) num [num]) (@ :: before).unit-array
.`minus : neg
# EOF

# start 'dep.lang'
::
_`wild (:: ([num] [num]) num [num]) before.((* 2) unit-array.)
.`plus : +
# EOF

# start 'use-dep.lang'
[:: micro-prelude`_ 
   (dep)`[_ : _`wild]   # here 'dep`_`wild is hidden

   # std                # note std would be imported by default (described in a manifest)
]

(f [(:: bool) std`array`reshape]

  5 minus. plus 9  # using our imports 'neg' and 'plus', this will return 4
  reshape [3 3]    # note reshape here will now comply with '4' using '_`scalar->array'
                   # doing '4 unit-array_@_reshape [3 3]'
  = 
  [[4 4 4]    
   [4 4 4]
   [4 4 4]
  ]               # then this will return 'true'

)
# EOF


# initially you will only be able to define a Compliant that
# is one function signature for one type
_ (:: (num num) [num] [num]) fmap-num            # these Compliants conflict, because the arguments are the same
_ (:: (num num) [num] num)   (@ :: before).first # the return type is irrelavent in determining what compliant to use




# Generics
# When declaring types, ' ` ' is used to indicate Generics 

(gen-func 
  [(:: ('T : 
        My-trait_,{output :: 'T}_char
        Hers
      )
      'G : Your-Trait_f64_,{return :: u8}
      'T 
   )
    My-Trait Your-Trait (Hers : Her-Trait)   # the traits are imported in this scope, 
                                             # but can also be used in the type signature
  ]
  MyTrait`do Your-Trait Hers
)


# We can make Compliants generic using generic syntax
_ (:: ('T 'T) ('T-map :: Functor_'T) 'T-map) Functor`fmap

# The last Compliant declared takes precedece over previous Compliants
(_ 
  [(:: (`T `T) (`T-map : F_`T) `T-map) 
    F : std`Functor
  ] 
  F`fmap
)

_ (:: (num num) ([num] [num])) fmap-num

(g (:: [num]) [1 2 3]) plus (:: num num) + 5   # here fmap-num would be used 
                                             # because it was declared most recently
                                             # and 'num num' would match before '`T `T'





\{5 + 6}  # a constant function, basically euivalent to (5 + 6)
\{:2 - :1}  # keywords will exist for the default left and right arguments
\{:2}       # this binary ignoring the first
\{:1}       # this is a unary id function
\{:3 \{:2} :1} # takes 3 values, returns the first

# you can use values above 2
\{:1 + :3} # a function that currys 3 arguments, the 2nd is ignored

fib :: <=_1.if_id_(fib.@_dec + fib.@_(dec @ dec))
fib :: \{<=_1.if_id_(:0.@_dec + :0.@_(dec @ dec))}                     # :0 is the function itself, so it can be used for recursive lambdas 

\{(:: num num num) :2 - :1}      # lambdas can be typed

?{a b c :: b - a + c}           # if you really want a full lambda, you can irrefutably match

?{,(a b c)  :: b - a + c}       # you can destructure a pattern
?{,(a b) c (:: ,(num num) num num) 
  b - a + c
}                               # also on binary arguments

                                # ' :| ' match guard , ' :? ' recursive call 
(fib :: ?{
    b :| <_1 :: id 
    g        :: g . :?.@_dec + :?.@_(dec @ dec)
  }
)

# Possible Type syntax
a (:: ,(num char)) ,(1 'a')   :# tuple
b (:: {x y})       {y_7 x_5}  :# anonymous record, structurally typed, unordered
a (:: ,[num 3])    ,[1 2 3]   :# static array

# Enums / tagged unions
bool := 1{true false}

# this syntax needs work
option:'T := 1{some_'T none}

result:'T:'E := 1{
  ok_'T := 'T 
  err_'E := 'E
}

(config := 1{
  test := {(version := string) (log := bool)}    # record variant
  (dev := { 
    version := string 
    hash    := u128
  })
  default
  basic
  tagged:(vec:string)
})

# The variants are distinct types
integer := 1{i8 i16 i32 i64 i128 i256}

# Making A nominally typed record is done with a newtype 
(vec3 := {
  x := (u : u16)
  y := u
  z := u
})



# Pattern matching uses lambda syntax

true:bool.?{(true :: 1) (false :: 2 + 4)}

# multiline

false:bool.?{
  true  :: 1
  false :: 2 + 4
}


(none.?{
  some_val :: val + 2
  none :: 5
})

(integer_5.?{
  5.i8  :: 1
  5.i16 :: 2
  5.i32 :: 3
  5.i64 :: 4
  a :: 0
})

# If there is only one variant, it is basically a lambda
(vec3_,{x_1 y_2 z_3}
 .
 ?{vec3_{x y (zed : z)} (:: vec3 num) x + y + zed}
)
 
?{
  (2d-point_{(bind1 : x)_(5 ..= 10) (bind2 : y)_7)} :: bind1 + bind2
  _ :: 0  
}


,['T '(int)]
a (: ,[('T : Sized) '(isize)]) .  # generic and const generic tuple

[1 2 3] reduce.+. % count.

[1 2 3] 0_fold_+.
[1 2 3] (fold.0)_+.


# Term rewriting
# Inverses

(inv 
  (.: 
    `F :: 'A 'B 'C 
    `I :: 'C 'B 'A
  )
  `F.inv :: `I
  `I.inv :: `F
)

inv_+ (:: num num num) + -_  # now both sides are inverses of each other inv_(+ -_)
inv_* (:: num num num) * %_

# Partial Inverse  

(p-inv
  (.:
    `F :: 'A 'B 'C        # the ` here denotes a concrete value F
    `I :: 'C 'B 'C
    `I.inv                # requirement
   )
  `F.p-inv :: `I  
  `I.p-inv :: `I.inv      # derives p-inv for `I
)

[] :: unit        # empty array has a space '[ ]'
flat.inv :: unit.at-rank_0                            # declare inverse, note both functions takes arrays and return arrays
[].p-inv :: flat                                   # now declare partial inverse

[].p-inv.inv :: unit.at-rank_0

(assoc 
  (.: 
    `A :: 'T 'T 'T 
    [`x `y `z] :: ['T]
  )
  `A.assoc :: `A
  (`x `A (`y `A `z)) :: `x `A `y `A `z
)

*.assoc :: *
+.assoc :: +

(commute 
  (.:
    `F :: 'T 'T 'T
    [`x `y] :: ['T]
  )
  `F.commute :: `F
  (`x `F `y) :: `y `F `x
)

(u-rank 
  (.: 
    `F :: ['T] ['T]
    `r :: num
  )
  `F.u-rank_`r :: F.at-rank_`r
  `F.what-u-rank :: `r
)


# Train behavior and Functional Colapse
# the type and evaluation of a Train is dependant on the 
# functions at the second + 2n positions
# Those functions take the return values of the left and right values
# as arguments, effectively meaning that they behave like infix functions.

a (:: num) ?        # beginning with a possible input 'a'
f (:: num num) ?    # and a unary function 'f'

# ex 1

a . f               # technically a and f are each a train with 1 'car'
                    #
                    # lets show the types
a (:: num) . f (:: num num)
                    # f is alone, and is therefore, satistifed with itself
                    # however '.' suggests that 1 argument will be passed
a (:: num) . f (:: num | num) 
                    # '|' and '!( .. )' are not syntax, it is used only to explicate
                    # we see the argument f requires is 'num'
                    # we look at the argument being passed and conclude that
                    # the type 'num' is satisfied with 'a'
a (:: !(num)) . f (:: !(num) | num) 
                    # therefore the value will colapse to a 'num'

# ex 2

b (:: num num num) ?  # this function takes 2 arguments

a b                   # this is no longer trivial, this a 2 'car' train
                      # all even trains end with the identity function
(a b) <==> {x :: a_x b x}
(a b) <==> a b id     # this will make sense later

                      # check the types
(a (:: num)) (b (:: num num num)) (id (:: `A `A))
                      # 'b' is in the last binary position, so we first declare
                      # the arguments it requires
(a (:: num)) (b (:: num num | num)) (id (:: `A `A))
                      # We then assert the right function 'id' must return a num
                      # since type '`A `A' would be a function, and b expects a num,
                      # '`A' must be num, and the return is then locked to a num
(a (:: num)) (b (:: num !(num) | num)) (id (:: num | !(num)))
                      # now that the return type of id has been found, the left of 'b'
                      # looks to be satistifed, and it is by 'a'
(a (:: | !(num))) (b (:: !(num) num | num)) (id (:: num | num))
                      # if 'id' did not still require an argument, 
                      # the function would colapse into a value,
                      # but because 
                      # the outer 'prongs' of the fork then determine the argument type,
                      # 'a' requires nothing and will ignore arguments as it
                      # 'id' requires a 'num', so 'a' will aquire dummy arguments indicated with '_'
(a (:: _ | num)) (b (:: num num | num)) (id (:: num | num))
                      # then arguments are compared to see if they match, where '_' matches anything
(a (:: arg(_) | num)) (b (:: num num | finalReturn(num))) (id (:: arg(num) | num))
                      # it matches to 'num' so
(a b) (:: arg(num) finalReturn(num))
(a b) (:: num num)

# ex 3


5 (+ * double) 6 + 5
(+_5_6 * double_5_(_6))


fold (:: 'A ('A 'B 'A) | ['B] 'A) ?
+ (:: | num num num)

0 fold + _ [1 2 3]

0.fold_+_[1 2 3]

# numeric literals
# users can define numeric literals for thier own types
# any numeric literal must begin with a number 0..9

# negative numbers
# since all numeric literals begin with a number 0..9,
# negatve numbers are indicated with a postfix -

4-
[4- 5- 8-]

5 + 4-

# imaginary numbers
6-i5.4      # -6 + 5.4i

# In a numeric literal there are some limits to the use of . _
0.0.0.6  # ip address?

0.u
8<u8>

0..6:(range:u8)

20..50

() [] {} : .

0 to 6

45;34;57:vec

0<12;13;14>

0<12;8;14> + 0..3 + 3:4

+_0_4
3.+_5.double

double_3.5

0<12:13:14>:(vec:u8).double

12'3"

0<<12,45><36_000-,9.6>>:(list:f64)

0<2..4'6..7'1..9>:(list:(range:u8))

4-

-3

2-/5

[4- 6- 8-]


1,000,000.25-

1'000'000.25-:fixed-point


1.598*10^23 + 5

(23 .: a_b)_c

1,000,000.25-:(type:a:b)

4+5i

8._.7
55
[4-+5i- 5- 6i 4]

4 + 3-:float64

[3:(posit_5_7) 4 5 6]

45;34;57:vec3




(fact (:: num num) 
  iota . (1 +).fmap  .: num [num]
  .
  1 fold *           .: [num] num
)


(fizzbuzz [(:: num [string])
    f :: "fizz"
    b :: "buzz"
  ]
  iota . (1 +).fmap
  .
  mod_3.fmap zip mod_5.fmap
  .
  ?{
    ,(0 0) :: f cat b
    ,(0 _) :: f
    ,(_ 0) :: b
  }.fmap
)
fizzbuzz_70
70.fizzbuzz




# Structural typing to the extreme

# Tuples are actually statically typed nested pairs
,(1 2 3) <=> ,(1 ,(2 3))
,(,(1 2) 3 4) <=> ,(,(1 2) ,(3 4))
,(,(1 2) ,(3 4) ,(5 6)) <=> ,(,(1 2) ,(,(3 4) ,(5 6)))

# Typedef ?
?{a b c :: a_b_c}
\{ :1_:2_:3 }


Result:'T:'E := 1{Ok:'T Err:'E}
Ok:'A  := 'A
Err:'B := 'B

(Result:'T:'E := 1{
  Ok  := 'T 
  Err := 'E
})

H  := 1{nil Box_H}
j  := {a b}
j1 := 1(j)
k  := {c 1(j)}


a      => {a b ..}
,(a b) => {a b}
,(b a) => {a b}

{}     => 0{a b ..}
a      => 1{a b ..}
,(b a) => 2{a b ..}
,(a b) => 2{a b ..}
,(a a)                               => ,[a 2]
,(,(b a) ,(a b)) => ,(2{a b} 2{a b}) => array:2:2{a b}


Option:'T := 1{Some:'T None}

zeros :: v3_{x_0 y_0 x_0}
a :: {x_5 .. zeros}:v3
j (:: {int char}) {'5' 0}

(vec3 := {
  x := u16
  y := u16
  z := u16
})


vec3 := {x y z}

x := u16
y := u16
z := u16
vec3 := {x y z}

v :: v3_{x_5 y_7 z_9}

(swap :: ?{ 
  val : v3_{x_a y_b ..} :: {y_a x_b .. val}:v3 
})
swap :: ?{ v3_{x_a y_b z_c} :: v3_{y_a x_b z_c} }


:# relational algebra on types?
g : {a b c}
G := {a b c}
j : {b c d}
J := {b c d}
k : union_g_j        :# <=> {a b c d e}
l : intersection:g:j :# <=> {b c}
m : anti-join:g:j    :# <=> {a}
l : {g j}            :# <=> union_g_j   :# auto flattening
L : {G J}            :# <=> {G J}       :# G and J are named, so they do not flatten
t : {G g}            :# <=> {G a b c}   :# note g will flatten


b : box:(1{tensor:num tensor:char})
[[2 3]:b 
 ["hey" "bro"]
]:tensor:b

v : vec:num
[4 5]:v

a : array:3:num
[5 6]:a

a : array:2:(v : vec:num)
[[1 2 3]:v
 [5 6 7]
]:a

v : vec:(a : array:3:num)
[[1 2 3]:a
 [4 5 6]
]:v

v : vec:(vec:num)
[[num]]:v1

[num]:vec:num

[num]:array:3:num
[num]:vec:num
[num]:tensor

[1 2 3]:(vec:num) . 0 fold +


f : {a b c}
k : {d e f}
u : {f k} <=> {a b c d e f}
i := 1{u}






tensor:'T : {
 shape   -: owned-slice:usize
 data:'T -: owned-slice:'T
}
owned-slice:'T : {
  offset :- usize 
  length :- usize
  arc:(raw-slice:'T)
}

animal:'T : {cat dog 'T}    :# note cat and dog cannot be 'T
a : animal:'T_1             :# 


apointment:'T : {time:'T place}
time:'T : 'T where ...
date       :- Array:3:num
place      : string

alarm :- time:hour

event:'T :- {time:'T place}
event:'T :- apointment:'T 

event:hour

message : {coordinates string}
coordinates :- Array:3:num

base : {Array:3:num string}

j (:: message) {coordinates_[1 2 3] "yoyoyo"}
j_coordinates


(Iterator:'T :- { 'T | (Item ) next)
next:'T:'G (:: 'T ,:option:'G) .. 



Optional:'T : {'T None}_1

{StreetAdress
 PostalCode
 City
 Country
 Name
}_(-1)



(sum:'T :  ['T 'T_[Iterator Output]]:fn | 'T member /_intersect_[Iterator EmptyElement +:'T]
  ::
  'T_EmptyElement fold +
)


'T_Iterator :- {'T .. Iterator} | (`T_[Iterator Output] :- ...) (next : ['T 'T_[Iterator Output]]:fn := ...)



{'T |
  'T | even_'T
  ..
  {u8_'A other yup}
}

()
[]
{}


('T | 'T member reduce_intersection_[Iterator Default Add])


[,('T 'G) | 
  {'T ..  0..15}  :# pattern match?
  [  ('G | 'G contains [3  5]) ..  [2 3 2 3]]
  {'T 'G}
]


{,('T 'G) |
  {'T .. {1 2 3 4}}  :# pattern match

  {'G .. {2 3 4 5 6}}

  {'T 'G}
  ..
  {u8_:all}        :# set comprehension requires an input set, the largest being `Type`
}


?{['T .. 0..9]  :: 'T}




()
[]
{}
('T | 'T_Iterator)
[|]





list:'T :- [num 'T]:object :: self idx
boolean : {true false}
bool: boolean_1

person :- name-age
car    :- name-age
name-age : {name age}
{name-age true} = {name age true}

age  :- num 
name :- string

[1 2 3]_1

double :: 2 *
f :: [double 2 triple]:([num Array:num]:fn)

f_4 = [8 2 12]

{3.2:posit id pair}:([num char {num ,(num char) posit}])

{3.2:posit id pair}_4_'h'
{(3.2:posit) id_4 pair_4}_'h'
{(3.2:posit) (id_4):num pair_4_'h'}
{<3.2:posit> (id_4):num ,(4 'h')}




[]:tuple






[1 2 3 4]

f :: [Array_num num]:fn 
f = 





a := {1 2 3}  # a set
b := {4 5 6}
c := a union b
d := 















